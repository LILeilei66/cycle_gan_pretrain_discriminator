from .base_model import BaseModel
from . import networks

class DiscriminateModel(BaseModel):
    """
    This DescriminateModel can be used to classify inputs into two categories.
    """

    @staticmethod
    def modify_commandline_options(parser, is_train=True):
        assert not is_train, 'DescriminateModel cannot be used during training time'
        parser.set_defaults(dataset_mode='single')
        parser.add_argument('--model_suffix', type=str, default='',
                            help='In checkpoints_dir, [epoch]_net_G[model_suffix].pth will be loaded as the generator.')
        return parser

    def __init__(self, opt):
        """Initialize the DescriminateModel class.

        Parameters:
            opt (Option class)-- stores all the experiment flags; needs to be a subclass of
            BaseOptions
        """
        assert(opt.isTrain) # 若 isTrain, 则必须loadNet
        BaseModel.__init__(self, opt)  # specify the training losses you want to print out. The

        # training/test scripts will call <BaseModel.get_current_losses>
        self.loss_names = ['D_A', 'G_A', 'cycle_A', 'idt_A', 'D_B', 'G_B', 'cycle_B', 'idt_B']
        # specify the images you want to save/display. The training/test scripts  will call
        # <BaseModel.get_current_visuals>
        self.visual_names = []
        # specify the models you want to save to the disk. The training/test scripts will call <BaseModel.save_networks> and <BaseModel.load_networks>
        self.model_names = ['D' + opt.model_suffix] # only discriminators
        # are needed.
        self.netD = networks.define_D(opt.output_nc, opt.ndf, opt.netD, opt.n_layers_D, opt.norm,
                                      opt.init_type, opt.init_gain)

        # assigns the model to self.netD_[suffix] so that it can be loaded
        # please see <BaseModel.load_networks>
        setattr(self, 'netD' + opt.model_suffix, self.netD)  # store netG in self.

        self.criterion = networks.GANLoss(opt.gan_mode).to(self.device)

    def set_input(self, input):
        """Unpack input data from the dataloader and perform necessary pre-processing steps.

        Parameters:
            input: a dictionary that contains the data itself and its metadata information.

        We need to use 'single_dataset' dataset mode. It only load images from one domain.
        """
        self.real_A = input['A'].to(self.device)
        self.image_paths = input['A_paths']
        print(self.real_A.shape)

    def forward(self):
        """Run forward pass."""
        self.features = self.netD(self.real_A) # D(A)

    def backward_D_basic(self, netD, real, fake):
        """Calculate GAN loss for the discriminator

        Parameters:
            netD (network)      -- the discriminator D
            real (tensor array) -- real images
            fake (tensor array) -- images generated by a generator

        Return the discriminator loss.
        We also call loss_D.backward() to calculate the gradients.
        """
        # TODO
        # Real
        pred_real = netD(real)
        pred_fake = netD(fake)
        loss_D_real = self.criterion()
        # TODO: Loss definition
        pass



    def optimize_parameters(self):
        """No optimization for discriminator model."""
        pass